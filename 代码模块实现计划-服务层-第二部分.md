# Mac屏幕录制与截图软件 - 服务层模块设计 (第二部分)

## 3. iCloud服务实现

### 3.1 iCloud服务核心实现
```swift
// iCloud服务实现
class iCloudService: CloudService, ObservableObject {
    let provider: CloudProvider = .iCloud
    @Published var isAuthenticated: Bool = false
    @Published var syncStatus: SyncStatus = .idle
    @Published var storageQuota: StorageQuota?
    
    private let ubiquityContainer: URL?
    private let fileManager = FileManager.default
    private let metadataQuery = NSMetadataQuery()
    
    init() {
        ubiquityContainer = fileManager.url(forUbiquityContainerIdentifier: nil)
        setupMetadataQuery()
        checkAuthenticationStatus()
    }
    
    func authenticate() async throws {
        guard ubiquityContainer != nil else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        // iCloud 不需要显式认证，检查容器可用性即可
        isAuthenticated = true
    }
    
    func signOut() async throws {
        // iCloud 无法程序化登出
        isAuthenticated = false
    }
    
    func refreshToken() async throws {
        // iCloud 使用系统级认证，无需刷新令牌
    }
    
    func upload(_ fileURL: URL, to remotePath: String, progress: @escaping (Double) -> Void) async throws -> CloudFile {
        guard let container = ubiquityContainer else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        let destinationURL = container.appendingPathComponent(remotePath)
        
        // 确保目标目录存在
        try fileManager.createDirectory(
            at: destinationURL.deletingLastPathComponent(),
            withIntermediateDirectories: true,
            attributes: nil
        )
        
        // 复制文件到 iCloud 容器
        try fileManager.copyItem(at: fileURL, to: destinationURL)
        
        // 开始上传到 iCloud
        try destinationURL.setResourceValue(true, forKey: .ubiquityItemDownloadRequestedKey)
        
        // 监控上传进度
        return try await monitorUploadProgress(for: destinationURL, progress: progress)
    }
    
    func download(_ cloudFile: CloudFile, to localURL: URL, progress: @escaping (Double) -> Void) async throws {
        guard let container = ubiquityContainer else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        let sourceURL = container.appendingPathComponent(cloudFile.path)
        
        // 请求下载文件
        try sourceURL.setResourceValue(true, forKey: .ubiquityItemDownloadRequestedKey)
        
        // 监控下载进度
        try await monitorDownloadProgress(for: sourceURL, to: localURL, progress: progress)
    }
    
    func listFiles(in path: String) async throws -> [CloudFile] {
        guard let container = ubiquityContainer else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        let directoryURL = container.appendingPathComponent(path)
        let contents = try fileManager.contentsOfDirectory(
            at: directoryURL,
            includingPropertiesForKeys: [
                .fileSizeKey,
                .contentModificationDateKey,
                .ubiquityItemDownloadingStatusKey
            ],
            options: []
        )
        
        var cloudFiles: [CloudFile] = []
        
        for url in contents {
            let resourceValues = try url.resourceValues(forKeys: [
                .fileSizeKey,
                .contentModificationDateKey,
                .isDirectoryKey,
                .ubiquityItemDownloadingStatusKey
            ])
            
            let cloudFile = CloudFile(
                id: url.lastPathComponent,
                name: url.lastPathComponent,
                path: url.path.replacingOccurrences(of: container.path, with: ""),
                size: Int64(resourceValues.fileSize ?? 0),
                modifiedDate: resourceValues.contentModificationDate ?? Date(),
                contentType: url.pathExtension,
                downloadURL: url,
                thumbnailURL: nil,
                isDirectory: resourceValues.isDirectory ?? false,
                provider: .iCloud
            )
            
            cloudFiles.append(cloudFile)
        }
        
        return cloudFiles
    }
    
    func createFolder(at path: String) async throws -> CloudFile {
        guard let container = ubiquityContainer else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        let folderURL = container.appendingPathComponent(path)
        try fileManager.createDirectory(
            at: folderURL,
            withIntermediateDirectories: true,
            attributes: nil
        )
        
        return CloudFile(
            id: folderURL.lastPathComponent,
            name: folderURL.lastPathComponent,
            path: path,
            size: 0,
            modifiedDate: Date(),
            contentType: "folder",
            downloadURL: folderURL,
            thumbnailURL: nil,
            isDirectory: true,
            provider: .iCloud
        )
    }
    
    func deleteFile(_ cloudFile: CloudFile) async throws {
        guard let container = ubiquityContainer else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        let fileURL = container.appendingPathComponent(cloudFile.path)
        try fileManager.removeItem(at: fileURL)
    }
    
    func moveFile(_ cloudFile: CloudFile, to newPath: String) async throws -> CloudFile {
        guard let container = ubiquityContainer else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        let sourceURL = container.appendingPathComponent(cloudFile.path)
        let destinationURL = container.appendingPathComponent(newPath)
        
        try fileManager.moveItem(at: sourceURL, to: destinationURL)
        
        var updatedFile = cloudFile
        updatedFile.path = newPath
        return updatedFile
    }
    
    func copyFile(_ cloudFile: CloudFile, to newPath: String) async throws -> CloudFile {
        guard let container = ubiquityContainer else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        let sourceURL = container.appendingPathComponent(cloudFile.path)
        let destinationURL = container.appendingPathComponent(newPath)
        
        try fileManager.copyItem(at: sourceURL, to: destinationURL)
        
        var copiedFile = cloudFile
        copiedFile.id = destinationURL.lastPathComponent
        copiedFile.path = newPath
        return copiedFile
    }
    
    func getStorageQuota() async throws -> StorageQuota {
        // iCloud 存储配额需要通过系统 API 获取
        return StorageQuota(
            totalSpace: 50_000_000_000, // 50GB
            usedSpace: 25_000_000_000,  // 25GB
            availableSpace: 25_000_000_000 // 25GB
        )
    }
    
    func getFileInfo(at path: String) async throws -> CloudFile {
        guard let container = ubiquityContainer else {
            throw CloudServiceError.iCloudNotAvailable
        }
        
        let fileURL = container.appendingPathComponent(path)
        let resourceValues = try fileURL.resourceValues(forKeys: [
            .fileSizeKey,
            .contentModificationDateKey,
            .isDirectoryKey
        ])
        
        return CloudFile(
            id: fileURL.lastPathComponent,
            name: fileURL.lastPathComponent,
            path: path,
            size: Int64(resourceValues.fileSize ?? 0),
            modifiedDate: resourceValues.contentModificationDate ?? Date(),
            contentType: fileURL.pathExtension,
            downloadURL: fileURL,
            thumbnailURL: nil,
            isDirectory: resourceValues.isDirectory ?? false,
            provider: .iCloud
        )
    }
    
    func startSync() async throws {
        syncStatus = .syncing(progress: 0.0)
        // 实现同步逻辑
    }
    
    func pauseSync() async throws {
        syncStatus = .paused
    }
    
    func stopSync() async throws {
        syncStatus = .idle
    }
    
    // MARK: - Private Methods
    
    private func setupMetadataQuery() {
        metadataQuery.searchScopes = [NSMetadataQueryUbiquitousDocumentsScope]
        metadataQuery.predicate = NSPredicate(format: "%K LIKE '*'", NSMetadataItemFSNameKey)
    }
    
    private func checkAuthenticationStatus() {
        isAuthenticated = ubiquityContainer != nil
    }
    
    private func monitorUploadProgress(for url: URL, progress: @escaping (Double) -> Void) async throws -> CloudFile {
        // 监控文件上传进度的实现
        return try await withCheckedThrowingContinuation { continuation in
            // 实现进度监控逻辑
            let cloudFile = CloudFile(
                id: url.lastPathComponent,
                name: url.lastPathComponent,
                path: url.path,
                size: 0,
                modifiedDate: Date(),
                contentType: url.pathExtension,
                downloadURL: url,
                thumbnailURL: nil,
                isDirectory: false,
                provider: .iCloud
            )
            continuation.resume(returning: cloudFile)
        }
    }
    
    private func monitorDownloadProgress(for sourceURL: URL, to localURL: URL, progress: @escaping (Double) -> Void) async throws {
        // 监控文件下载进度的实现
        try await withCheckedThrowingContinuation { continuation in
            // 实现进度监控逻辑
            try? fileManager.copyItem(at: sourceURL, to: localURL)
            continuation.resume()
        }
    }
}
```

## 4. 通知服务 (NotificationService)

### 4.1 通知类型定义
```swift
// 应用通知类型
enum AppNotificationType {
    case screenshotTaken(URL)           // 截图完成
    case recordingStarted               // 录制开始
    case recordingCompleted(URL)        // 录制完成
    case editingCompleted(URL)          // 编辑完成
    case cloudSyncCompleted             // 云同步完成
    case cloudSyncFailed(Error)         // 云同步失败
    case lowDiskSpace                   // 磁盘空间不足
    case permissionRequired(PermissionType) // 需要权限
    case updateAvailable(String)        // 有可用更新
    case error(Error)                   // 错误通知
}

// 应用通知结构
struct AppNotification {
    let id: UUID = UUID()
    let type: AppNotificationType
    let title: String
    let message: String
    let actionTitle: String?
    let action: (() -> Void)?
    let timestamp: Date = Date()
    let priority: NotificationPriority
    
    enum NotificationPriority {
        case low
        case normal
        case high
        case critical
    }
}
```

### 4.2 通知服务实现
```swift
// 通知服务
class NotificationService: ObservableObject {
    @Published var notifications: [AppNotification] = []
    @Published var unreadCount: Int = 0
    
    private let userNotificationCenter = UNUserNotificationCenter.current()
    private var notificationPermissionGranted = false
    
    init() {
        requestNotificationPermission()
        setupNotificationDelegate()
    }
    
    // 显示通知
    func showNotification(_ notification: AppNotification) {
        // 添加到内部通知列表
        DispatchQueue.main.async {
            self.notifications.insert(notification, at: 0)
            self.unreadCount += 1
            
            // 保持通知列表在合理大小
            if self.notifications.count > 50 {
                self.notifications.removeLast()
            }
        }
        
        // 发送系统通知
        if notificationPermissionGranted {
            sendSystemNotification(notification)
        }
    }
    
    // 计划通知
    func scheduleNotification(_ notification: AppNotification, at date: Date) {
        let content = UNMutableNotificationContent()
        content.title = notification.title
        content.body = notification.message
        content.sound = .default
        
        let timeInterval = date.timeIntervalSinceNow
        guard timeInterval > 0 else { return }
        
        let trigger = UNTimeIntervalNotificationTrigger(
            timeInterval: timeInterval,
            repeats: false
        )
        
        let request = UNNotificationRequest(
            identifier: notification.id.uuidString,
            content: content,
            trigger: trigger
        )
        
        userNotificationCenter.add(request) { error in
            if let error = error {
                print("Failed to schedule notification: \(error)")
            }
        }
    }
    
    // 清除所有通知
    func clearAllNotifications() {
        DispatchQueue.main.async {
            self.notifications.removeAll()
            self.unreadCount = 0
        }
        
        userNotificationCenter.removeAllPendingNotificationRequests()
        userNotificationCenter.removeAllDeliveredNotifications()
    }
    
    // 标记通知为已读
    func markAsRead(_ notification: AppNotification) {
        DispatchQueue.main.async {
            if let index = self.notifications.firstIndex(where: { $0.id == notification.id }) {
                // 这里可以添加已读状态标记
                self.unreadCount = max(0, self.unreadCount - 1)
            }
        }
    }
    
    // 移除通知
    func removeNotification(_ notification: AppNotification) {
        DispatchQueue.main.async {
            self.notifications.removeAll { $0.id == notification.id }
            self.unreadCount = max(0, self.unreadCount - 1)
        }
        
        userNotificationCenter.removePendingNotificationRequests(
            withIdentifiers: [notification.id.uuidString]
        )
    }
    
    // MARK: - Private Methods
    
    private func requestNotificationPermission() {
        userNotificationCenter.requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            DispatchQueue.main.async {
                self.notificationPermissionGranted = granted
            }
            
            if let error = error {
                print("Notification permission error: \(error)")
            }
        }
    }
    
    private func setupNotificationDelegate() {
        userNotificationCenter.delegate = self
    }
    
    private func sendSystemNotification(_ notification: AppNotification) {
        let content = UNMutableNotificationContent()
        content.title = notification.title
        content.body = notification.message
        content.sound = .default
        
        // 根据优先级设置不同的通知样式
        switch notification.priority {
        case .critical:
            content.sound = .defaultCritical
        case .high:
            content.sound = .default
        default:
            content.sound = nil
        }
        
        let request = UNNotificationRequest(
            identifier: notification.id.uuidString,
            content: content,
            trigger: nil // 立即发送
        )
        
        userNotificationCenter.add(request) { error in
            if let error = error {
                print("Failed to send notification: \(error)")
            }
        }
    }
}

// MARK: - UNUserNotificationCenterDelegate
extension NotificationService: UNUserNotificationCenterDelegate {
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        willPresent notification: UNNotification,
        withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void
    ) {
        // 应用在前台时也显示通知
        completionHandler([.banner, .sound])
    }
    
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        didReceive response: UNNotificationResponse,
        withCompletionHandler completionHandler: @escaping () -> Void
    ) {
        let notificationId = response.notification.request.identifier
        
        // 查找对应的通知并执行操作
        if let notification = notifications.first(where: { $0.id.uuidString == notificationId }) {
            notification.action?()
        }
        
        completionHandler()
    }
}
```

## 5. 分析服务 (AnalyticsService)

### 5.1 分析事件定义
```swift
// 分析事件类型
enum AnalyticsEvent {
    case appLaunched
    case appTerminated
    case screenshotTaken(type: String, format: String)
    case recordingStarted(duration: TimeInterval, format: String)
    case recordingCompleted(duration: TimeInterval, fileSize: Int64)
    case editingSessionStarted
    case editingOperationPerformed(type: String)
    case settingsChanged(category: String)
    case cloudSyncPerformed(provider: String, fileCount: Int)
    case errorOccurred(error: String, context: String)
    case featureUsed(feature: String)
    case performanceMetric(metric: String, value: Double)
    
    var eventName: String {
        switch self {
        case .appLaunched: return "app_launched"
        case .appTerminated: return "app_terminated"
        case .screenshotTaken: return "screenshot_taken"
        case .recordingStarted: return "recording_started"
        case .recordingCompleted: return "recording_completed"
        case .editingSessionStarted: return "editing_session_started"
        case .editingOperationPerformed: return "editing_operation_performed"
        case .settingsChanged: return "settings_changed"
        case .cloudSyncPerformed: return "cloud_sync_performed"
        case .errorOccurred: return "error_occurred"
        case .featureUsed: return "feature_used"
        case .performanceMetric: return "performance_metric"
        }
    }
    
    var parameters: [String: Any] {
        switch self {
        case .screenshotTaken(let type, let format):
            return ["type": type, "format": format]
        case .recordingStarted(let duration, let format):
            return ["duration": duration, "format": format]
        case .recordingCompleted(let duration, let fileSize):
            return ["duration": duration, "file_size": fileSize]
        case .editingOperationPerformed(let type):
            return ["operation_type": type]
        case .settingsChanged(let category):
            return ["category": category]
        case .cloudSyncPerformed(let provider, let fileCount):
            return ["provider": provider, "file_count": fileCount]
        case .errorOccurred(let error, let context):
            return ["error": error, "context": context]
        case .featureUsed(let feature):
            return ["feature": feature]
        case .performanceMetric(let metric, let value):
            return ["metric": metric, "value": value]
        default:
            return [:]
        }
    }
}
```

### 5.2 分析服务实现
```swift
// 分析服务
class AnalyticsService: ObservableObject {
    @Published var isEnabled: Bool = false
    
    private let sessionId = UUID().uuidString
    private let sessionStartTime = Date()
    private var eventQueue: [AnalyticsEvent] = []
    private let maxQueueSize = 100
    
    init() {
        loadAnalyticsSettings()
        startSession()
    }
    
    // 记录事件
    func track(_ event: AnalyticsEvent) {
        guard isEnabled else { return }
        
        eventQueue.append(event)
        
        // 当队列达到一定大小时批量发送
        if eventQueue.count >= maxQueueSize {
            flushEvents()
        }
        
        // 记录到本地日志
        logEventLocally(event)
    }
    
    // 记录屏幕视图
    func trackScreenView(_ screenName: String) {
        track(.featureUsed(feature: "screen_view_\(screenName)"))
    }
    
    // 记录用户属性
    func setUserProperty(_ key: String, value: Any) {
        guard isEnabled else { return }
        
        // 实现用户属性设置
        let userDefaults = UserDefaults.standard
        userDefaults.set(value, forKey: "analytics_user_\(key)")
    }
    
    // 记录性能指标
    func trackPerformance(_ metric: String, value: Double) {
        track(.performanceMetric(metric: metric, value: value))
    }
    
    // 启用/禁用分析
    func setAnalyticsEnabled(_ enabled: Bool) {
        isEnabled = enabled
        UserDefaults.standard.set(enabled, forKey: "analytics_enabled")
        
        if !enabled {
            // 清除本地数据
            clearLocalData()
        }
    }
    
    // 刷新事件队列
    func flushEvents() {
        guard !eventQueue.isEmpty else { return }
        
        // 这里实现发送事件到分析服务的逻辑
        // 例如发送到 Firebase Analytics, Mixpanel 等
        
        eventQueue.removeAll()
    }
    
    // MARK: - Private Methods
    
    private func loadAnalyticsSettings() {
        isEnabled = UserDefaults.standard.bool(forKey: "analytics_enabled")
    }
    
    private func startSession() {
        if isEnabled {
            track(.appLaunched)
        }
    }
    
    private func logEventLocally(_ event: AnalyticsEvent) {
        // 记录到本地日志文件
        let logEntry = [
            "timestamp": ISO8601DateFormatter().string(from: Date()),
            "session_id": sessionId,
            "event": event.eventName,
            "parameters": event.parameters
        ]
        
        // 写入本地日志文件
        writeToLocalLog(logEntry)
    }
    
    private func writeToLocalLog(_ entry: [String: Any]) {
        // 实现本地日志写入逻辑
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return
        }
        
        let logFileURL = documentsPath.appendingPathComponent("analytics.log")
        
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: entry, options: [])
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                let logLine = jsonString + "\n"
                
                if FileManager.default.fileExists(atPath: logFileURL.path) {
                    let fileHandle = try FileHandle(forWritingTo: logFileURL)
                    fileHandle.seekToEndOfFile()
                    fileHandle.write(logLine.data(using: .utf8) ?? Data())
                    fileHandle.closeFile()
                } else {
                    try logLine.write(to: logFileURL, atomically: true, encoding: .utf8)
                }
            }
        } catch {
            print("Failed to write analytics log: \(error)")
        }
    }
    
    private func clearLocalData() {
        // 清除本地分析数据
        guard let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return
        }
        
        let logFileURL = documentsPath.appendingPathComponent("analytics.log")
        
        try? FileManager.default.removeItem(at: logFileURL)
        
        // 清除用户属性
        let userDefaults = UserDefaults.standard
        let keys = userDefaults.dictionaryRepresentation().keys
        for key in keys {
            if key.hasPrefix("analytics_user_") {
                userDefaults.removeObject(forKey: key)
            }
        }
    }
}
```

## 6. 模块间接口规范

### 6.1 数据流转方式
```swift
// 使用Combine框架进行响应式数据流
class DataFlowManager {
    let screenshotSubject = PassthroughSubject<ScreenshotResult, Never>()
    let recordingSubject = PassthroughSubject<RecordingResult, Never>()
    let editingSubject = PassthroughSubject<EditResult, Never>()
    
    // 数据流转协调
    func coordinateDataFlow() {
        // 实现模块间数据传递逻辑
    }
}
```

### 6.2 模块通信协议
```swift
protocol ModuleCommunication {
    func sendMessage(_ message: ModuleMessage) async
    func receiveMessage(_ message: ModuleMessage) async
}

struct ModuleMessage {
    let sender: ModuleType
    let receiver: ModuleType
    let payload: Any
    let timestamp: Date
}
```

---

**文档版本**: 1.0.0  
**创建日期**: 2025年9月25日  
**最后更新**: 2025年9月25日