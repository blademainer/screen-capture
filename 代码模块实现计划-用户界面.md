# Mac屏幕录制与截图软件 - 用户界面模块设计

## 1. 主界面架构 (MainUI)

### 1.1 界面结构设计
```swift
// 主应用结构
@main
struct ScreenCaptureApp: App {
    @StateObject private var appState = AppState()
    @StateObject private var settingsManager = SettingsManager()
    
    var body: some Scene {
        WindowGroup {
            MainView()
                .environmentObject(appState)
                .environmentObject(settingsManager)
        }
        .windowStyle(.hiddenTitleBar)
        .windowResizability(.contentSize)
        
        MenuBarExtra("ScreenCapture", systemImage: "camera.fill") {
            MenuBarView()
                .environmentObject(appState)
        }
        .menuBarExtraStyle(.window)
    }
}

// 主视图
struct MainView: View {
    @EnvironmentObject private var appState: AppState
    @State private var selectedTab: MainTab = .capture
    
    var body: some View {
        NavigationSplitView {
            SidebarView(selectedTab: $selectedTab)
        } detail: {
            ContentView(selectedTab: selectedTab)
        }
        .frame(minWidth: 800, minHeight: 600)
        .toolbar {
            ToolbarView()
        }
        .sheet(isPresented: $appState.showingSettings) {
            SettingsView()
        }
    }
}
```

### 1.2 侧边栏设计
```swift
// 侧边栏视图
struct SidebarView: View {
    @Binding var selectedTab: MainTab
    
    var body: some View {
        List(selection: $selectedTab) {
            Section("捕获") {
                NavigationLink(value: MainTab.capture) {
                    Label("截图录制", systemImage: "camera")
                }
                NavigationLink(value: MainTab.recent) {
                    Label("最近文件", systemImage: "clock")
                }
            }
            
            Section("编辑") {
                NavigationLink(value: MainTab.editor) {
                    Label("编辑器", systemImage: "pencil")
                }
                NavigationLink(value: MainTab.batch) {
                    Label("批量处理", systemImage: "square.stack")
                }
            }
            
            Section("管理") {
                NavigationLink(value: MainTab.cloud) {
                    Label("云同步", systemImage: "icloud")
                }
                NavigationLink(value: MainTab.settings) {
                    Label("设置", systemImage: "gear")
                }
            }
        }
        .navigationSplitViewColumnWidth(min: 200, ideal: 250)
    }
}
```

### 1.3 菜单栏集成
```swift
// 菜单栏视图
struct MenuBarView: View {
    @EnvironmentObject private var appState: AppState
    
    var body: some View {
        VStack(spacing: 8) {
            // 快速操作按钮
            QuickActionButtons()
            
            Divider()
            
            // 最近文件
            RecentFilesMenu()
            
            Divider()
            
            // 设置和退出
            Button("偏好设置...") {
                appState.showSettings()
            }
            .keyboardShortcut(",", modifiers: .command)
            
            Button("退出") {
                NSApplication.shared.terminate(nil)
            }
            .keyboardShortcut("q", modifiers: .command)
        }
        .padding()
        .frame(width: 250)
    }
}
```

## 2. 截图界面 (ScreenshotUI)

### 2.1 区域选择界面
```swift
// 截图覆盖窗口
struct ScreenshotOverlayWindow: NSWindow {
    init() {
        super.init(
            contentRect: NSScreen.main?.frame ?? .zero,
            styleMask: [.borderless, .fullSizeContentView],
            backing: .buffered,
            defer: false
        )
        
        self.level = .screenSaver
        self.backgroundColor = NSColor.clear
        self.isOpaque = false
        self.hasShadow = false
        self.ignoresMouseEvents = false
        
        self.contentView = ScreenshotOverlayView()
    }
}

// 截图覆盖视图实现
class ScreenshotOverlayNSView: NSView {
    private var selectionRect: CGRect = .zero
    private var isSelecting: Bool = false
    private var startPoint: CGPoint = .zero
    
    override func draw(_ dirtyRect: NSRect) {
        super.draw(dirtyRect)
        
        // 绘制半透明遮罩
        NSColor.black.withAlphaComponent(0.3).setFill()
        bounds.fill()
        
        // 绘制选择区域
        if !selectionRect.isEmpty {
            NSColor.clear.setFill()
            selectionRect.fill(using: .sourceOut)
            
            // 绘制选择框边框
            NSColor.systemBlue.setStroke()
            let borderPath = NSBezierPath(rect: selectionRect)
            borderPath.lineWidth = 2.0
            borderPath.stroke()
            
            // 绘制尺寸信息
            drawDimensionInfo()
        }
    }
    
    override func mouseDown(with event: NSEvent) {
        startPoint = convert(event.locationInWindow, from: nil)
        isSelecting = true
        selectionRect = CGRect(origin: startPoint, size: .zero)
    }
    
    override func mouseDragged(with event: NSEvent) {
        guard isSelecting else { return }
        
        let currentPoint = convert(event.locationInWindow, from: nil)
        selectionRect = CGRect(
            x: min(startPoint.x, currentPoint.x),
            y: min(startPoint.y, currentPoint.y),
            width: abs(currentPoint.x - startPoint.x),
            height: abs(currentPoint.y - startPoint.y)
        )
        
        needsDisplay = true
    }
    
    override func mouseUp(with event: NSEvent) {
        isSelecting = false
        
        if selectionRect.width > 10 && selectionRect.height > 10 {
            // 执行截图
            NotificationCenter.default.post(
                name: .screenshotRegionSelected,
                object: selectionRect
            )
        }
        
        window?.close()
    }
    
    private func drawDimensionInfo() {
        let infoText = "\(Int(selectionRect.width)) × \(Int(selectionRect.height))"
        let attributes: [NSAttributedString.Key: Any] = [
            .font: NSFont.systemFont(ofSize: 12),
            .foregroundColor: NSColor.white,
            .backgroundColor: NSColor.black.withAlphaComponent(0.7)
        ]
        
        let attributedString = NSAttributedString(string: infoText, attributes: attributes)
        let textSize = attributedString.size()
        
        let textRect = CGRect(
            x: selectionRect.maxX - textSize.width - 5,
            y: selectionRect.minY - textSize.height - 5,
            width: textSize.width + 10,
            height: textSize.height + 4
        )
        
        attributedString.draw(in: textRect)
    }
}
```

### 2.2 快速操作面板
```swift
// 快速操作面板
struct QuickActionPanel: View {
    @EnvironmentObject private var appState: AppState
    @State private var isHovered: Bool = false
    
    var body: some View {
        HStack(spacing: 12) {
            ActionButton(
                icon: "viewfinder",
                title: "区域截图",
                shortcut: "⌘⇧4"
            ) {
                appState.startRegionScreenshot()
            }
            
            ActionButton(
                icon: "macwindow",
                title: "窗口截图",
                shortcut: "⌘⇧4 Space"
            ) {
                appState.startWindowScreenshot()
            }
            
            ActionButton(
                icon: "display",
                title: "全屏截图",
                shortcut: "⌘⇧3"
            ) {
                appState.startFullScreenshot()
            }
            
            ActionButton(
                icon: "scroll",
                title: "滚动截图",
                shortcut: "⌘⇧5"
            ) {
                appState.startScrollingScreenshot()
            }
            
            Divider()
            
            ActionButton(
                icon: "record.circle",
                title: appState.isRecording ? "停止录制" : "开始录制",
                shortcut: "⌘⇧R",
                isActive: appState.isRecording
            ) {
                appState.toggleRecording()
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(.regularMaterial)
                .shadow(radius: 8)
        )
        .scaleEffect(isHovered ? 1.05 : 1.0)
        .animation(.easeInOut(duration: 0.2), value: isHovered)
        .onHover { hovering in
            isHovered = hovering
        }
    }
}

// 操作按钮
struct ActionButton: View {
    let icon: String
    let title: String
    let shortcut: String
    let isActive: Bool
    let action: () -> Void
    
    init(icon: String, title: String, shortcut: String, isActive: Bool = false, action: @escaping () -> Void) {
        self.icon = icon
        self.title = title
        self.shortcut = shortcut
        self.isActive = isActive
        self.action = action
    }
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundColor(isActive ? .red : .primary)
                
                Text(title)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text(shortcut)
                    .font(.caption2)
                    .foregroundColor(.tertiary)
            }
            .frame(width: 80, height: 60)
        }
        .buttonStyle(.plain)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(isActive ? Color.red.opacity(0.1) : Color.clear)
        )
    }
}
```

## 3. 录制界面 (RecordingUI)

### 3.1 录制控制面板
```swift
// 录制控制面板
struct RecordingControlPanel: View {
    @EnvironmentObject private var recordingEngine: RecordingEngine
    @State private var showingRegionSelector: Bool = false
    
    var body: some View {
        VStack(spacing: 16) {
            // 录制状态显示
            RecordingStatusView()
            
            // 录制控制按钮
            HStack(spacing: 12) {
                if recordingEngine.isRecording {
                    Button(action: { recordingEngine.pauseRecording() }) {
                        Image(systemName: recordingEngine.isPaused ? "play.fill" : "pause.fill")
                        Text(recordingEngine.isPaused ? "继续" : "暂停")
                    }
                    .keyboardShortcut("p", modifiers: [.command, .shift])
                    
                    Button(action: { recordingEngine.stopRecording() }) {
                        Image(systemName: "stop.fill")
                        Text("停止")
                    }
                    .keyboardShortcut("r", modifiers: [.command, .shift])
                    .buttonStyle(.borderedProminent)
                    
                    Button(action: { recordingEngine.cancelRecording() }) {
                        Image(systemName: "xmark")
                        Text("取消")
                    }
                    .keyboardShortcut(.escape)
                } else {
                    Button(action: { showingRegionSelector = true }) {
                        Image(systemName: "viewfinder")
                        Text("选择区域录制")
                    }
                    
                    Button(action: { recordingEngine.startFullScreenRecording() }) {
                        Image(systemName: "display")
                        Text("全屏录制")
                    }
                    .keyboardShortcut("r", modifiers: [.command, .shift])
                    .buttonStyle(.borderedProminent)
                }
            }
            
            // 录制设置快速调整
            if !recordingEngine.isRecording {
                RecordingQuickSettings()
            }
        }
        .padding()
        .background(.regularMaterial, in: RoundedRectangle(cornerRadius: 12))
        .sheet(isPresented: $showingRegionSelector) {
            RegionSelectorView()
        }
    }
}
```

### 3.2 录制状态显示
```swift
// 录制状态视图
struct RecordingStatusView: View {
    @EnvironmentObject private var recordingEngine: RecordingEngine
    
    var body: some View {
        VStack(spacing: 8) {
            if recordingEngine.isRecording {
                HStack {
                    Circle()
                        .fill(.red)
                        .frame(width: 8, height: 8)
                        .opacity(recordingEngine.isPaused ? 0.5 : 1.0)
                        .animation(.easeInOut(duration: 1.0).repeatForever(), value: recordingEngine.isPaused)
                    
                    Text(recordingEngine.isPaused ? "录制已暂停" : "正在录制")
                        .font(.headline)
                        .foregroundColor(recordingEngine.isPaused ? .orange : .red)
                }
                
                Text(formatDuration(recordingEngine.currentDuration))
                    .font(.title2.monospacedDigit())
                    .foregroundColor(.primary)
                
                // 性能指标
                if let stats = recordingEngine.statistics {
                    HStack(spacing: 16) {
                        StatusIndicator(
                            title: "CPU",
                            value: "\(Int(stats.averageCPUUsage))%",
                            color: stats.averageCPUUsage > 80 ? .red : .green
                        )
                        
                        StatusIndicator(
                            title: "内存",
                            value: formatBytes(stats.peakMemoryUsage),
                            color: stats.peakMemoryUsage > 1_000_000_000 ? .orange : .green
                        )
                        
                        StatusIndicator(
                            title: "丢帧",
                            value: "\(stats.droppedFrames)",
                            color: stats.droppedFrames > 10 ? .red : .green
                        )
                    }
                    .font(.caption)
                }
            } else {
                Text("准备录制")
                    .font(.headline)
                    .foregroundColor(.secondary)
            }
        }
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = Int(duration) % 3600 / 60
        let seconds = Int(duration) % 60
        
        if hours > 0 {
            return String(format: "%02d:%02d:%02d", hours, minutes, seconds)
        } else {
            return String(format: "%02d:%02d", minutes, seconds)
        }
    }
    
    private func formatBytes(_ bytes: Int64) -> String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .memory
        return formatter.string(fromByteCount: bytes)
    }
}
```

## 4. 编辑界面 (EditingUI)

### 4.1 编辑器主界面
```swift
// 编辑器主视图
struct EditorView: View {
    @StateObject private var editingEngine = EditingEngine()
    @State private var selectedTool: EditingTool = .select
    @State private var showingToolProperties: Bool = false
    
    var body: some View {
        HSplitView {
            // 工具面板
            ToolPalette(selectedTool: $selectedTool)
                .frame(width: 60)
            
            // 主编辑区域
            VStack(spacing: 0) {
                // 工具栏
                EditingToolbar(
                    selectedTool: $selectedTool,
                    showingProperties: $showingToolProperties
                )
                
                // 画布区域
                CanvasView()
                    .environmentObject(editingEngine)
                
                // 时间轴 (视频编辑)
                if editingEngine.currentContent?.contentType == .video {
                    TimelineView()
                        .frame(height: 100)
                }
            }
            
            // 属性面板
            if showingToolProperties {
                PropertiesPanel(selectedTool: selectedTool)
                    .frame(width: 250)
            }
        }
        .navigationTitle("编辑器")
        .toolbar {
            EditingToolbarItems()
        }
    }
}
```

### 4.2 工具调色板
```swift
// 工具调色板
struct ToolPalette: View {
    @Binding var selectedTool: EditingTool
    
    var body: some View {
        VStack(spacing: 8) {
            ForEach(EditingTool.allCases, id: \.self) { tool in
                Button(action: { selectedTool = tool }) {
                    Image(systemName: tool.iconName)
                        .font(.title2)
                        .foregroundColor(selectedTool == tool ? .white : .primary)
                        .frame(width: 40, height: 40)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(selectedTool == tool ? .accentColor : .clear)
                        )
                }
                .buttonStyle(.plain)
                .help(tool.displayName)
            }
            
            Spacer()
        }
        .padding(.vertical)
        .background(.regularMaterial)
    }
}

// 编辑工具枚举
enum EditingTool: String, CaseIterable {
    case select = "select"
    case arrow = "arrow"
    case text = "text"
    case rectangle = "rectangle"
    case circle = "circle"
    case line = "line"
    case highlight = "highlight"
    case mosaic = "mosaic"
    case crop = "crop"
    
    var iconName: String {
        switch self {
        case .select: return "cursorarrow"
        case .arrow: return "arrow.up.right"
        case .text: return "textformat"
        case .rectangle: return "rectangle"
        case .circle: return "circle"
        case .line: return "line.diagonal"
        case .highlight: return "highlighter"
        case .mosaic: return "mosaic"
        case .crop: return "crop"
        }
    }
    
    var displayName: String {
        switch self {
        case .select: return "选择"
        case .arrow: return "箭头"
        case .text: return "文字"
        case .rectangle: return "矩形"
        case .circle: return "圆形"
        case .line: return "直线"
        case .highlight: return "高亮"
        case .mosaic: return "马赛克"
        case .crop: return "裁剪"
        }
    }
}
```

## 5. 设置界面 (SettingsUI)

### 5.1 设置主界面
```swift
// 设置窗口
struct SettingsView: View {
    @State private var selectedCategory: SettingsCategory = .general
    
    var body: some View {
        NavigationSplitView {
            SettingsSidebar(selectedCategory: $selectedCategory)
                .frame(width: 200)
        } detail: {
            SettingsDetailView(category: selectedCategory)
                .frame(minWidth: 500, minHeight: 400)
        }
        .navigationTitle("偏好设置")
        .frame(width: 700, height: 500)
    }
}

// 设置分类枚举
enum SettingsCategory: String, CaseIterable {
    case general = "general"
    case shortcuts = "shortcuts"
    case recording = "recording"
    case screenshot = "screenshot"
    case output = "output"
    case cloud = "cloud"
    case advanced = "advanced"
    
    var displayName: String {
        switch self {
        case .general: return "通用"
        case .shortcuts: return "快捷键"
        case .recording: return "录制"
        case .screenshot: return "截图"
        case .output: return "输出"
        case .cloud: return "云同步"
        case .advanced: return "高级"
        }
    }
    
    var iconName: String {
        switch self {
        case .general: return "gear"
        case .shortcuts: return "keyboard"
        case .recording: return "record.circle"
        case .screenshot: return "camera"
        case .output: return "square.and.arrow.up"
        case .cloud: return "icloud"
        case .advanced: return "slider.horizontal.3"
        }
    }
}
```

### 5.2 通用设置界面
```swift
// 通用设置视图
struct GeneralSettingsView: View {
    @EnvironmentObject private var settingsManager: SettingsManager
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("通用设置")
                .font(.title2)
                .fontWeight(.semibold)
            
            GroupBox("启动选项") {
                VStack(alignment: .leading, spacing: 12) {
                    Toggle("开机自动启动", isOn: $settingsManager.generalSettings.launchAtStartup)
                    Toggle("显示菜单栏图标", isOn: $settingsManager.generalSettings.showInMenuBar)
                    Toggle("自动检查更新", isOn: $settingsManager.generalSettings.checkForUpdates)
                }
                .padding()
            }
            
            GroupBox("界面设置") {
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Text("主题:")
                        Picker("主题", selection: $settingsManager.generalSettings.theme) {
                            Text("跟随系统").tag(AppTheme.system)
                            Text("浅色模式").tag(AppTheme.light)
                            Text("深色模式").tag(AppTheme.dark)
                        }
                        .pickerStyle(.segmented)
                    }
                    
                    HStack {
                        Text("语言:")
                        Picker("语言", selection: $settingsManager.generalSettings.language) {
                            Text("跟随系统").tag(AppLanguage.system)
                            Text("简体中文").tag(AppLanguage.simplifiedChinese)
                            Text("English").tag(AppLanguage.english)
                        }
                        .frame(width: 150)
                    }
                }
                .padding()
            }
            
            GroupBox("文件管理") {
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Text("默认保存位置:")
                        TextField("路径", text: .constant(settingsManager.generalSettings.defaultSaveLocation.path))
                            .textFieldStyle(.roundedBorder)
                        Button("选择...") {
                            // 打开文件选择器
                        }
                    }
                    
                    HStack {
                        Text("文件命名模式:")
                        TextField("命名模式", text: $settingsManager.generalSettings.fileNamingPattern)
                            .textFieldStyle(.roundedBorder)
                    }
                }
                .padding()
            }
        }
    }
}
```

## 6. 界面交互设计

### 6.1 拖拽支持
```swift
// 拖拽处理器
struct DragDropHandler: DropDelegate {
    let onFilesDropped: ([URL]) -> Void
    
    func performDrop(info: DropInfo) -> Bool {
        guard let itemProviders = info.itemProviders(for: [.fileURL]) else {
            return false
        }
        
        var urls: [URL] = []
        let group = DispatchGroup()
        
        for itemProvider in itemProviders {
            group.enter()
            itemProvider.loadItem(forTypeIdentifier: UTType.fileURL.identifier, options: nil) { item, error in
                defer { group.leave() }
                
                if let data = item as? Data,
                   let url = URL(dataRepresentation: data, relativeTo: nil) {
                    urls.append(url)
                }
            }
        }
        
        group.notify(queue: .main) {
            if !urls.isEmpty {
                onFilesDropped(urls)
            }
        }
        
        return true
    }
    
    func validateDrop(info: DropInfo) -> Bool {
        return info.hasItemsConforming(to: [.fileURL])
    }
}
```

### 6.2 键盘快捷键处理
```swift
// 全局快捷键管理器
class GlobalShortcutManager: ObservableObject {
    private var shortcuts: [String: GlobalShortcut] = [:]
    
    func registerShortcut(
        _ keyCombo: KeyCombination,
        identifier: String,
        handler: @escaping () -> Void
    ) {
        let shortcut = GlobalShortcut(
            keyCombo: keyCombo,
            handler: handler
        )
        
        shortcuts[identifier] = shortcut
        shortcut.register()
    }
    
    func unregisterShortcut(identifier: String) {
        shortcuts[identifier]?.unregister()
        shortcuts.removeValue(forKey: identifier)
    }
    
    func updateShortcut(
        identifier: String,
        newKeyCombo: KeyCombination
    ) {
        guard let shortcut = shortcuts[identifier] else { return }
        
        shortcut.unregister()
        shortcut.keyCombo = newKeyCombo
        shortcut.register()
    }
}
```

### 6.3 动画和过渡效果
```swift
// 自定义动画
extension Animation {
    static let smoothEaseInOut = Animation.easeInOut(duration: 0.3)
    static let quickSpring = Animation.spring(response: 0.4, dampingFraction: 0.8)
    static let slowFade = Animation.easeInOut(duration: 0.6)
}

// 过渡效果
struct SlideTransition: ViewModifier {
    let isVisible: Bool
    let direction: Edge
    
    func body(content: Content) -> some View {
        content
            .opacity(isVisible ? 1 : 0)
            .offset(
                x: direction == .leading ? (isVisible ? 0 : -50) : (direction == .trailing ? (isVisible ? 0 : 50) : 0),
                y: direction == .top ? (isVisible ? 0 : -50) : (direction == .bottom ? (isVisible ? 0 : 50) : 0)
            )
            .animation(.smoothEaseInOut, value: isVisible)
    }
}
```

---

**文档版本**: 1.0.0  
**创建日期**: 2025年9月25日  
**最后更新**: 2025年9月25日