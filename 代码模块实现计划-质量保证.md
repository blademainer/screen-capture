# Mac屏幕录制与截图软件 - 质量保证和维护性方案

## 1. 代码质量标准

### 1.1 编码规范
#### Swift代码规范
```swift
// 命名规范
class ScreenshotEngine {                    // 类名使用PascalCase
    private let captureSession: AVCaptureSession  // 属性使用camelCase
    
    func captureScreen() -> ScreenshotResult {    // 方法名使用camelCase
        // 实现
    }
}

// 常量命名
struct Constants {
    static let maxFileSize: Int64 = 100_000_000    // 使用下划线分隔大数字
    static let defaultTimeout: TimeInterval = 30.0
}

// 枚举命名
enum CaptureType: String, CaseIterable {
    case fullscreen = "fullscreen"
    case region = "region"
    case window = "window"
}
```

#### 代码组织结构
```
ScreenCapture/
├── Core/
│   ├── Screenshot/
│   │   ├── ScreenshotEngine.swift
│   │   ├── ScreenshotConfig.swift
│   │   └── ScreenshotError.swift
│   ├── Recording/
│   │   ├── RecordingEngine.swift
│   │   ├── RecordingConfig.swift
│   │   └── RecordingError.swift
│   └── Editing/
│       ├── EditingEngine.swift
│       ├── EditOperation.swift
│       └── Annotation.swift
├── UI/
│   ├── Views/
│   ├── ViewModels/
│   └── Components/
├── Services/
│   ├── PermissionService.swift
│   ├── CloudService.swift
│   └── NotificationService.swift
└── Utils/
    ├── Extensions/
    ├── Helpers/
    └── Constants/
```

### 1.2 代码质量检查工具

#### SwiftLint配置
```yaml
# .swiftlint.yml
disabled_rules:
  - trailing_whitespace
  - force_cast
  - force_try

opt_in_rules:
  - empty_count
  - explicit_init
  - first_where
  - sorted_first_last
  - unneeded_parentheses_in_closure_argument

included:
  - Sources
  - Tests

excluded:
  - Carthage
  - Pods
  - .build

line_length:
  warning: 120
  error: 200

function_body_length:
  warning: 50
  error: 100

type_body_length:
  warning: 300
  error: 500

file_length:
  warning: 500
  error: 1000

cyclomatic_complexity:
  warning: 10
  error: 20

nesting:
  type_level:
    warning: 3
    error: 6
  statement_level:
    warning: 5
    error: 10
```

#### 静态代码分析
```swift
// 使用Xcode内置的静态分析器
// Build Settings -> Static Analyzer -> Analyze During 'Build' = YES

// 自定义分析规则
class CodeAnalyzer {
    // 检查循环引用
    func checkRetainCycles() {
        // 实现循环引用检测逻辑
    }
    
    // 检查未使用的代码
    func checkDeadCode() {
        // 实现死代码检测逻辑
    }
    
    // 检查性能问题
    func checkPerformanceIssues() {
        // 实现性能问题检测逻辑
    }
}
```

### 1.3 代码审查流程

#### Pull Request模板
```markdown
## 变更描述
简要描述本次变更的内容和目的

## 变更类型
- [ ] 新功能
- [ ] Bug修复
- [ ] 性能优化
- [ ] 重构
- [ ] 文档更新
- [ ] 测试

## 测试
- [ ] 单元测试已通过
- [ ] 集成测试已通过
- [ ] 手动测试已完成
- [ ] 性能测试已完成

## 检查清单
- [ ] 代码符合项目规范
- [ ] 已添加必要的测试
- [ ] 已更新相关文档
- [ ] 无明显的性能问题
- [ ] 无安全漏洞

## 截图/演示
如果涉及UI变更，请提供截图或演示视频
```

#### 代码审查标准
```swift
// 审查要点示例
class ReviewChecklist {
    // 1. 功能正确性
    func checkFunctionality() {
        // - 代码是否实现了预期功能
        // - 边界条件是否正确处理
        // - 错误处理是否完善
    }
    
    // 2. 代码质量
    func checkCodeQuality() {
        // - 代码是否清晰易读
        // - 命名是否恰当
        // - 是否遵循SOLID原则
    }
    
    // 3. 性能考虑
    func checkPerformance() {
        // - 是否有性能瓶颈
        // - 内存使用是否合理
        // - 算法复杂度是否可接受
    }
    
    // 4. 安全性
    func checkSecurity() {
        // - 是否有安全漏洞
        // - 敏感数据是否正确处理
        // - 权限检查是否完善
    }
}
```

## 2. 测试质量保证

### 2.1 测试覆盖率要求
```swift
// 测试覆盖率目标
// - 整体代码覆盖率: > 80%
// - 核心模块覆盖率: > 90%
// - UI测试覆盖率: > 70%
// - 集成测试覆盖率: > 85%

class CoverageReporter {
    func generateCoverageReport() {
        // 使用xccov生成覆盖率报告
        let command = """
        xcrun xccov view --report --json \
        DerivedData/ScreenCapture/Logs/Test/*.xcresult
        """
        
        // 解析覆盖率数据
        // 生成HTML报告
        // 检查覆盖率是否达标
    }
    
    func checkCoverageThreshold() -> Bool {
        let currentCoverage = getCurrentCoverage()
        let threshold = 0.80 // 80%
        
        return currentCoverage >= threshold
    }
}
```

### 2.2 自动化测试策略
```swift
// 测试金字塔结构
class TestPyramid {
    // 单元测试 (70%)
    func unitTests() {
        // - 测试单个函数/方法
        // - 快速执行
        // - 高覆盖率
    }
    
    // 集成测试 (20%)
    func integrationTests() {
        // - 测试模块间交互
        // - 数据库/网络集成
        // - API测试
    }
    
    // UI测试 (10%)
    func uiTests() {
        // - 端到端用户场景
        // - 关键用户路径
        // - 跨平台兼容性
    }
}
```

### 2.3 测试数据管理
```swift
class TestDataManager {
    // 测试数据工厂
    static func createTestScreenshot() -> NSImage {
        let size = CGSize(width: 1920, height: 1080)
        let image = NSImage(size: size)
        
        image.lockFocus()
        NSColor.systemBlue.setFill()
        NSRect(origin: .zero, size: size).fill()
        image.unlockFocus()
        
        return image
    }
    
    // 测试配置
    static func createTestConfig() -> ScreenshotConfig {
        return ScreenshotConfig(
            captureType: .fullscreen,
            targetDisplay: nil,
            region: nil,
            includeWindowShadow: false,
            outputFormat: .png(.medium),
            quality: 1.0,
            includeMouseCursor: false,
            delaySeconds: 0
        )
    }
    
    // 清理测试数据
    func cleanupTestData() {
        let testDirectory = FileManager.default.temporaryDirectory
            .appendingPathComponent("ScreenCaptureTests")
        
        try? FileManager.default.removeItem(at: testDirectory)
    }
}
```

## 3. 性能监控和优化

### 3.1 性能指标定义
```swift
struct PerformanceMetrics {
    // 响应时间指标
    let screenshotCaptureTime: TimeInterval    // < 0.5秒
    let recordingStartTime: TimeInterval       // < 2.0秒
    let editingOperationTime: TimeInterval     // < 0.1秒
    let fileSaveTime: TimeInterval            // < 1.0秒
    
    // 资源使用指标
    let memoryUsage: Int64                    // < 200MB
    let cpuUsage: Double                      // < 30%
    let diskUsage: Int64                      // 合理范围
    let batteryImpact: BatteryImpact          // 低影响
    
    // 稳定性指标
    let crashRate: Double                     // < 0.1%
    let errorRate: Double                     // < 1%
    let successRate: Double                   // > 99%
}

enum BatteryImpact {
    case low, medium, high
}
```

### 3.2 性能监控系统
```swift
class PerformanceMonitor: ObservableObject {
    @Published var currentMetrics = PerformanceMetrics()
    
    private let metricsCollector = MetricsCollector()
    private let alertThresholds = AlertThresholds()
    
    func startMonitoring() {
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            self.collectMetrics()
            self.checkThresholds()
        }
    }
    
    private func collectMetrics() {
        // 收集CPU使用率
        let cpuUsage = metricsCollector.getCPUUsage()
        
        // 收集内存使用
        let memoryUsage = metricsCollector.getMemoryUsage()
        
        // 收集磁盘I/O
        let diskUsage = metricsCollector.getDiskUsage()
        
        // 更新指标
        DispatchQueue.main.async {
            self.currentMetrics = PerformanceMetrics(
                screenshotCaptureTime: 0,
                recordingStartTime: 0,
                editingOperationTime: 0,
                fileSaveTime: 0,
                memoryUsage: memoryUsage,
                cpuUsage: cpuUsage,
                diskUsage: diskUsage,
                batteryImpact: .low,
                crashRate: 0,
                errorRate: 0,
                successRate: 100
            )
        }
    }
    
    private func checkThresholds() {
        if currentMetrics.memoryUsage > alertThresholds.maxMemoryUsage {
            sendAlert(.highMemoryUsage(currentMetrics.memoryUsage))
        }
        
        if currentMetrics.cpuUsage > alertThresholds.maxCPUUsage {
            sendAlert(.highCPUUsage(currentMetrics.cpuUsage))
        }
    }
    
    private func sendAlert(_ alert: PerformanceAlert) {
        // 发送性能警报
        NotificationCenter.default.post(
            name: .performanceAlert,
            object: alert
        )
    }
}

enum PerformanceAlert {
    case highMemoryUsage(Int64)
    case highCPUUsage(Double)
    case slowResponse(TimeInterval)
    case highErrorRate(Double)
}
```

### 3.3 内存管理优化
```swift
class MemoryManager {
    // 图像缓存管理
    private let imageCache = NSCache<NSString, NSImage>()
    
    init() {
        setupCache()
        setupMemoryWarningObserver()
    }
    
    private func setupCache() {
        imageCache.countLimit = 50
        imageCache.totalCostLimit = 100 * 1024 * 1024 // 100MB
    }
    
    private func setupMemoryWarningObserver() {
        NotificationCenter.default.addObserver(
            forName: NSApplication.didReceiveMemoryWarningNotification,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.handleMemoryWarning()
        }
    }
    
    private func handleMemoryWarning() {
        // 清理缓存
        imageCache.removeAllObjects()
        
        // 释放临时资源
        cleanupTemporaryResources()
        
        // 强制垃圾回收
        autoreleasepool {
            // 执行内存清理操作
        }
    }
    
    private func cleanupTemporaryResources() {
        // 清理临时文件
        let tempDirectory = FileManager.default.temporaryDirectory
        let tempFiles = try? FileManager.default.contentsOfDirectory(
            at: tempDirectory,
            includingPropertiesForKeys: [.creationDateKey],
            options: []
        )
        
        tempFiles?.forEach { url in
            let resourceValues = try? url.resourceValues(forKeys: [.creationDateKey])
            if let creationDate = resourceValues?.creationDate,
               Date().timeIntervalSince(creationDate) > 3600 { // 1小时前的文件
                try? FileManager.default.removeItem(at: url)
            }
        }
    }
}
```

## 4. 错误处理和日志系统

### 4.1 统一错误处理
```swift
// 应用级错误定义
enum AppError: Error, LocalizedError {
    case screenshot(ScreenshotError)
    case recording(RecordingError)
    case editing(EditingError)
    case fileManagement(FileError)
    case permission(PermissionError)
    case network(NetworkError)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .screenshot(let error):
            return "截图错误: \(error.localizedDescription)"
        case .recording(let error):
            return "录制错误: \(error.localizedDescription)"
        case .editing(let error):
            return "编辑错误: \(error.localizedDescription)"
        case .fileManagement(let error):
            return "文件管理错误: \(error.localizedDescription)"
        case .permission(let error):
            return "权限错误: \(error.localizedDescription)"
        case .network(let error):
            return "网络错误: \(error.localizedDescription)"
        case .unknown(let error):
            return "未知错误: \(error.localizedDescription)"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .screenshot(.permissionDenied):
            return "请在系统偏好设置中授予屏幕录制权限"
        case .recording(.diskSpaceInsufficient):
            return "请清理磁盘空间后重试"
        case .permission(.screenRecordingDenied):
            return "请在系统偏好设置 > 安全性与隐私 > 屏幕录制中启用权限"
        default:
            return "请重试或联系技术支持"
        }
    }
}

// 错误处理器
class ErrorHandler: ObservableObject {
    @Published var currentError: AppError?
    @Published var showErrorAlert = false
    
    private let logger = Logger.shared
    private let analytics = AnalyticsService.shared
    
    func handle(_ error: Error, context: String = "") {
        let appError = mapToAppError(error)
        
        // 记录错误日志
        logger.error("Error occurred", metadata: [
            "error": "\(appError)",
            "context": "\(context)",
            "timestamp": "\(Date())"
        ])
        
        // 发送错误分析
        analytics.track(.errorOccurred(
            error: appError.localizedDescription,
            context: context
        ))
        
        // 更新UI状态
        DispatchQueue.main.async {
            self.currentError = appError
            self.showErrorAlert = true
        }
    }
    
    private func mapToAppError(_ error: Error) -> AppError {
        switch error {
        case let screenshotError as ScreenshotError:
            return .screenshot(screenshotError)
        case let recordingError as RecordingError:
            return .recording(recordingError)
        case let editingError as EditingError:
            return .editing(editingError)
        case let fileError as FileError:
            return .fileManagement(fileError)
        case let permissionError as PermissionError:
            return .permission(permissionError)
        case let networkError as NetworkError:
            return .network(networkError)
        default:
            return .unknown(error)
        }
    }
}
```

### 4.2 日志系统
```swift
import OSLog

class Logger {
    static let shared = Logger()
    
    private let subsystem = "com.screenCapture.app"
    private let category = "general"
    
    private let osLogger = OSLog(subsystem: subsystem, category: category)
    private let fileLogger = FileLogger()
    
    private init() {}
    
    func debug(_ message: String, metadata: [String: String] = [:]) {
        log(level: .debug, message: message, metadata: metadata)
    }
    
    func info(_ message: String, metadata: [String: String] = [:]) {
        log(level: .info, message: message, metadata: metadata)
    }
    
    func warning(_ message: String, metadata: [String: String] = [:]) {
        log(level: .default, message: message, metadata: metadata)
    }
    
    func error(_ message: String, metadata: [String: String] = [:]) {
        log(level: .error, message: message, metadata: metadata)
    }
    
    func critical(_ message: String, metadata: [String: String] = [:]) {
        log(level: .fault, message: message, metadata: metadata)
    }
    
    private func log(level: OSLogType, message: String, metadata: [String: String]) {
        let formattedMessage = formatMessage(message, metadata: metadata)
        
        // 系统日志
        os_log("%{public}@", log: osLogger, type: level, formattedMessage)
        
        // 文件日志
        fileLogger.write(level: level, message: formattedMessage)
        
        // 开发环境控制台输出
        #if DEBUG
        print("[\(levelString(level))] \(formattedMessage)")
        #endif
    }
    
    private func formatMessage(_ message: String, metadata: [String: String]) -> String {
        var formatted = message
        
        if !metadata.isEmpty {
            let metadataString = metadata
                .map { "\($0.key)=\($0.value)" }
                .joined(separator: ", ")
            formatted += " [\(metadataString)]"
        }
        
        return formatted
    }
    
    private func levelString(_ level: OSLogType) -> String {
        switch level {
        case .debug: return "DEBUG"
        case .info: return "INFO"
        case .default: return "WARNING"
        case .error: return "ERROR"
        case .fault: return "CRITICAL"
        default: return "UNKNOWN"
        }
    }
}

class FileLogger {
    private let logFileURL: URL
    private let dateFormatter = DateFormatter()
    private let queue = DispatchQueue(label: "com.screenCapture.fileLogger", qos: .utility)
    
    init() {
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        logFileURL = documentsPath.appendingPathComponent("app.log")
        
        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss.SSS"
    }
    
    func write(level: OSLogType, message: String) {
        queue.async {
            let timestamp = self.dateFormatter.string(from: Date())
            let levelString = self.levelString(level)
            let logEntry = "[\(timestamp)] [\(levelString)] \(message)\n"
            
            if let data = logEntry.data(using: .utf8) {
                if FileManager.default.fileExists(atPath: self.logFileURL.path) {
                    if let fileHandle = try? FileHandle(forWritingTo: self.logFileURL) {
                        fileHandle.seekToEndOfFile()
                        fileHandle.write(data)
                        fileHandle.closeFile()
                    }
                } else {
                    try? data.write(to: self.logFileURL)
                }
            }
            
            // 日志文件大小控制
            self.rotateLogIfNeeded()
        }
    }
    
    private func rotateLogIfNeeded() {
        guard let attributes = try? FileManager.default.attributesOfItem(atPath: logFileURL.path),
              let fileSize = attributes[.size] as? Int64,
              fileSize > 10 * 1024 * 1024 else { // 10MB
            return
        }
        
        // 备份当前日志文件
        let backupURL = logFileURL.appendingPathExtension("backup")
        try? FileManager.default.removeItem(at: backupURL)
        try? FileManager.default.moveItem(at: logFileURL, to: backupURL)
    }
    
    private func levelString(_ level: OSLogType) -> String {
        switch level {
        case .debug: return "DEBUG"
        case .info: return "INFO"
        case .default: return "WARNING"
        case .error: return "ERROR"
        case .fault: return "CRITICAL"
        default: return "UNKNOWN"
        }
    }
}
```

## 5. 安全性保证

### 5.1 数据安全
```swift
class SecurityManager {
    // 敏感数据加密
    func encryptSensitiveData(_ data: Data) -> Data? {
        guard let key = getEncryptionKey() else { return nil }
        
        let algorithm = SecKeyAlgorithm.eciesEncryptionCofactorVariableIVX963SHA256AESGCM
        
        var error: Unmanaged<CFError>?
        guard let encryptedData = SecKeyCreateEncryptedData(
            key,
            algorithm,
            data as CFData,
            &error
        ) else {
            return nil
        }
        
        return encryptedData as Data
    }
    
    // 获取加密密钥
    private func getEncryptionKey() -> SecKey? {
        let keyTag = "com.screenCapture.encryptionKey"
        let query: [String: Any] = [
            kSecClass as String: kSecClassKey,
            kSecAttrApplicationTag as String: keyTag,
            kSecReturnRef as String: true
        ]
        
        var item: CFTypeRef?
        let status = SecItemCopyMatching(query as CFDictionary, &item)
        
        if status == errSecSuccess {
            return (item as! SecKey)
        } else {
            return generateNewKey(tag: keyTag)
        }
    }
    
    private func generateNewKey(tag: String) -> SecKey? {
        let attributes: [String: Any] = [
            kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,
            kSecAttrKeySizeInBits as String: 256,
            kSecPrivateKeyAttrs as String: [
                kSecAttrIsPermanent as String: true,
                kSecAttrApplicationTag as String: tag
            ]
        ]
        
        var error: Unmanaged<CFError>?
        guard let privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &error) else {
            return nil
        }
        
        return privateKey
    }
    
    // 安全删除文件
    func secureDeleteFile(at url: URL) throws {
        let fileSize = try FileManager.default.attributesOfItem(atPath: url.path)[.size] as! Int64
        
        // 多次覆写文件内容
        let fileHandle = try FileHandle(forWritingTo: url)
        defer { fileHandle.closeFile() }
        
        for _ in 0..<3 {
            fileHandle.seek(toFileOffset: 0)
            let randomData = Data((0..<fileSize).map { _ in UInt8.random(in: 0...255) })
            fileHandle.write(randomData)
            fileHandle.synchronizeFile()
        }
        
        // 删除文件
        try FileManager.default.removeItem(at: url)
    }
}
```

### 5.2 权限验证
```swift
class PermissionValidator {
    // 验证屏幕录制权限
    func validateScreenRecordingPermission() -> Bool {
        if #available(macOS 10.15, *) {
            return CGPreflightScreenCaptureAccess()
        }
        return true
    }
    
    // 验证文件访问权限
    func validateFileAccessPermission(for url: URL) -> Bool {
        return FileManager.default.isReadableFile(atPath: url.path) &&
               FileManager.default.isWritableFile(atPath: url.path)
    }
    
    // 验证网络访问权限
    func validateNetworkPermission() -> Bool {
        // 检查网络访问权限
        return true
    }
    
    // 权限状态监控
    func startPermissionMonitoring() {
        Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { _ in
            self.checkAllPermissions()
        }
    }
    
    private func checkAllPermissions() {
        let permissions = [
            ("Screen Recording", validateScreenRecordingPermission()),
            ("File Access", validateFileAccessPermission(for: FileManager.default.homeDirectoryForCurrentUser)),
            ("Network", validateNetworkPermission())
        ]
        
        for (name, granted) in permissions {
            if !granted {
                Logger.shared.warning("Permission not granted: \(name)")
                NotificationCenter.default.post(
                    name: .permissionStatusChanged,
                    object: (name, granted)
                )
            }
        }
    }
}
```

## 6. 可维护性设计

### 6.1 模块化架构
```swift
// 依赖注入容器
class DIContainer {
    private var services: [String: Any] = [:]
    
    func register<T>(_ type: T.Type, factory: @escaping () -> T) {
        let key = String(describing: type)
        services[key] = factory
    }
    
    func resolve<T>(_ type: T.Type) -> T? {
        let key = String(describing: type)
        guard let factory = services[key] as? () -> T else {
            return nil
        }
        return factory()
    }
}

// 服务定位器
class ServiceLocator {
    static let shared = ServiceLocator()
    private let container = DIContainer()
    
    private init() {
        registerServices()
    }
    
    private func registerServices() {
        container.register(ScreenshotEngine.self) { ScreenshotEngine() }
        container.register(RecordingEngine.self) { RecordingEngine() }
        container.register(EditingEngine.self) { EditingEngine() }
        container.register(FileManager.self) { FileManager() }
        container.register(PermissionService.self) { PermissionService() }
    }
    
    func get<T>(_ type: T.Type) -> T? {
        return container.resolve(type)
    }
}
```

### 6.2 配置管理
```swift
// 配置管理器
class ConfigurationManager: ObservableObject {
    @Published var configuration: AppConfiguration
    
    private let configFileURL: URL
    private let fileManager = FileManager.default
    
    init() {
        let documentsPath = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first!
        configFileURL = documentsPath.appendingPathComponent("app_config.json")
        
        configuration = loadConfiguration()
    }
    
    private func loadConfiguration() -> AppConfiguration {
        guard fileManager.fileExists(atPath: configFileURL.path),
              let data = try? Data(contentsOf: configFileURL),
              let config = try? JSONDecoder().decode(AppConfiguration.self, from: data) else {
            return AppConfiguration.default
        }
        
        return config
    }
    
    func saveConfiguration() {
        do {
            let data = try JSONEncoder().encode(configuration)
            try data.write(to: configFileURL)
        } catch {
            Logger.shared.error("Failed to save configuration: \(error)")
        }
    }
    
    func resetToDefaults() {
        configuration = AppConfiguration.default
        saveConfiguration()
    }
}

// 应用配置结构
struct AppConfiguration: Codable {
    var screenshot: ScreenshotConfiguration
    var recording: RecordingConfiguration
    var editing: EditingConfiguration
    var ui: UIConfiguration
    var performance: PerformanceConfiguration
    
    static let `default` = AppConfiguration(
        screenshot: ScreenshotConfiguration.default,
        recording: RecordingConfiguration.default,
        editing: EditingConfiguration.default,
        ui: UIConfiguration.default,
        performance: PerformanceConfiguration.default
    )
}

struct ScreenshotConfiguration: Codable {
    var defaultFormat: ImageFormat
    var defaultQuality: Float
    var includeMouseCursor: Bool
    var playSound: Bool
    var autoSave: Bool
    var savePath: String
    
    static let `default` = ScreenshotConfiguration(
        defaultFormat: .png(.medium),
        defaultQuality: 1.0,
        includeMouseCursor: false,
        playSound: true,
        autoSave: true,
        savePath: "~/Desktop"
    )
}
```

### 6.3 国际化支持
```swift
// 本地化管理器
class LocalizationManager: ObservableObject {
    @Published var currentLanguage: Language = .system
    
    enum Language: String, CaseIterable {
        case system = "system"
        case english = "en"
        case chinese = "zh-Hans"
        case japanese = "ja"
        
        var displayName: String {
            switch self {
            case .system: return NSLocalizedString("System", comment: "")
            case .english: return "English"
            case .chinese: return "中文"
            case .japanese: return "日本語"
            }
        }
    }
    
    func setLanguage(_ language: Language) {
        currentLanguage = language
        
        if language != .system {
            UserDefaults.standard.set([language.rawValue], forKey: "AppleLanguages")
        } else {
            UserDefaults.standard.removeObject(forKey: "AppleLanguages")
        }
        
        // 通知应用重新加载本地化字符串
        NotificationCenter.default.post(name: .languageChanged, object: language)
    }
    
    func localizedString(for key: String, comment: String = "") -> String {
        return NSLocalizedString(key, comment: comment)
    }
}

// 本地化字符串扩展
extension String {
    var localized: String {
        return NSLocalizedString(self, comment: "")
    }
    
    func localized(with arguments: CVarArg...) -> String {
        return String(format: NSLocalizedString(self, comment: ""), arguments: arguments)
    }
}
```

## 7. 文档和知识管理

### 7.1 代码文档
```swift
/// 屏幕截图引擎
/// 
/// 提供各种类型的屏幕截图功能，包括全屏、区域、窗口和滚动截图。
/// 支持多种输出格式和质量设置。
///
/// ## 使用示例
/// ```swift
/// let engine = ScreenshotEngine()
/// let config = ScreenshotConfig(captureType: .fullscreen)
/// let result = try await engine.captureScreen(config: config)
/// ```
///
/// ## 性能考虑
/// - 截图操作在后台线程执行
/// - 大图像会自动进行内存优化
/// - 支持并发截图，但建议限制在3个以内
///
/// - Author: 开发团队
/// - Version: 1.0.0
/// - Since: 2025.9.25
class ScreenshotEngine {
    
    /// 执行屏幕截图
    /// 
    /// - Parameter config: 截图配置参数
    /// - Returns: 截图结果，包含图像和元数据
    /// - Throws: `ScreenshotError` 当截图失败时
    /// 
    /// ## 错误处理
    /// 可能抛出的错误类型：
    /// - `ScreenshotError.permissionDenied`: 权限被拒绝
    /// - `ScreenshotError.displayNotFound`: 显示器未找到
    /// - `ScreenshotError.regionOutOfBounds`: 区域超出边界
    /// 
    /// ## 性能指标
    /// - 响应时间: < 0.5秒
    /// - 内存占用: < 100MB
    /// - 支持最大分辨率: 8K
    func captureScreen(config: ScreenshotConfig) async throws -> ScreenshotResult {
        // 实现
    }
}
```

### 7.2 API文档生成
```swift
// 使用Swift-DocC生成文档
// Package.swift配置
let package = Package(
    name: "ScreenCapture",
    platforms: [.macOS(.v10_15)],
    products: [
        .library(name: "ScreenCapture", targets: ["ScreenCapture"])
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-docc-plugin", from: "1.0.0")
    ],
    targets: [
        .target(
            name: "ScreenCapture",
            dependencies: []
        ),
        .testTarget(
            name: "ScreenCaptureTests",
            dependencies: ["ScreenCapture"]
        )
    ]
)
```

### 7.3 变更日志管理
```markdown
# 变更日志

本文档记录了项目的所有重要变更。

格式基于 [Keep a Changelog](https://keepachangelog.com/zh-CN/1.0.0/)，
版本号遵循 [语义化版本](https://semver.org/lang/zh-CN/)。

## [未发布]

### 新增
- 新功能描述

### 变更
- 现有功能的变更

### 修复
- Bug修复

### 移除
- 移除的功能

## [1.0.0] - 2025-12-25

### 新增
- 屏幕截图功能
  - 全屏截图
  - 区域截图
  - 窗口截图
  - 滚动截图
- 屏幕录制功能
  - 高质量录制 (最高60fps)
  - 音频录制
  - 多种编码格式
- 图像编辑功能
  - 标注工具
  - 滤镜效果
  - 基础调整
- 文件管理
  - 多格式输出
  - 批量处理
  - 云存储同步
- 用户界面
  - 现代化设计
  - 快捷键支持
  - 设置管理

### 技术改进
- 性能优化
- 内存管理改进
- 错误处理完善
- 测试覆盖率提升

## [0.9.0] - 2025-12-18 (Beta)

### 新增
- Beta版本发布
- 核心功能实现

## [0.1.0] - 2025-10-01 (Alpha)

### 新增
- 项目初始化
- 基础架构搭建
```

---

**文档版本**: 1.0.0  
**创建日期**: 2025年9月25日  
**最后更新**: 2025年9月25日