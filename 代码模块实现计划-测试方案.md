# Mac屏幕录制与截图软件 - 测试方案

## 1. 测试策略概述

### 1.1 测试目标
- 确保所有功能模块按照需求正常工作
- 验证系统在各种环境下的稳定性和性能
- 保证用户体验的一致性和可靠性
- 确保代码质量和可维护性

### 1.2 测试类型
- **单元测试**: 测试各个模块的独立功能
- **集成测试**: 测试模块间的交互和数据流
- **性能测试**: 验证系统性能指标
- **兼容性测试**: 确保在不同系统版本上的兼容性
- **用户界面测试**: 验证UI交互和用户体验
- **安全测试**: 确保权限管理和数据安全

### 1.3 测试环境
- **开发环境**: 日常开发和调试
- **测试环境**: 功能验证和集成测试
- **预生产环境**: 性能测试和最终验证
- **生产环境**: 监控和问题追踪

## 2. 单元测试

### 2.1 截图模块测试
```swift
import XCTest
@testable import ScreenCapture

class ScreenshotEngineTests: XCTestCase {
    var screenshotEngine: ScreenshotEngine!
    
    override func setUp() {
        super.setUp()
        screenshotEngine = ScreenshotEngine()
    }
    
    override func tearDown() {
        screenshotEngine = nil
        super.tearDown()
    }
    
    // 测试区域截图功能
    func testRegionCapture() async throws {
        let config = ScreenshotConfig(
            captureType: .region,
            targetDisplay: NSScreen.main,
            region: CGRect(x: 0, y: 0, width: 100, height: 100),
            includeWindowShadow: false,
            outputFormat: .png(.medium),
            quality: 1.0,
            includeMouseCursor: false,
            delaySeconds: 0
        )
        
        let result = try await screenshotEngine.captureScreen(config: config)
        
        XCTAssertNotNil(result.image)
        XCTAssertEqual(result.image.size.width, 100)
        XCTAssertEqual(result.image.size.height, 100)
        XCTAssertNotNil(result.metadata)
        XCTAssertTrue(result.timestamp.timeIntervalSinceNow < 1.0)
    }
    
    // 测试全屏截图功能
    func testFullScreenCapture() async throws {
        let config = ScreenshotConfig(
            captureType: .fullscreen,
            targetDisplay: NSScreen.main,
            region: nil,
            includeWindowShadow: false,
            outputFormat: .png(.medium),
            quality: 1.0,
            includeMouseCursor: false,
            delaySeconds: 0
        )
        
        let result = try await screenshotEngine.captureScreen(config: config)
        
        XCTAssertNotNil(result.image)
        XCTAssertGreaterThan(result.image.size.width, 0)
        XCTAssertGreaterThan(result.image.size.height, 0)
    }
    
    // 测试显示器检测功能
    func testDisplayDetection() {
        let displays = screenshotEngine.getAvailableDisplays()
        
        XCTAssertGreaterThan(displays.count, 0)
        XCTAssertNotNil(displays.first)
    }
    
    // 测试无效区域处理
    func testInvalidRegionHandling() async {
        let config = ScreenshotConfig(
            captureType: .region,
            targetDisplay: NSScreen.main,
            region: CGRect(x: -100, y: -100, width: 50, height: 50),
            includeWindowShadow: false,
            outputFormat: .png(.medium),
            quality: 1.0,
            includeMouseCursor: false,
            delaySeconds: 0
        )
        
        do {
            _ = try await screenshotEngine.captureScreen(config: config)
            XCTFail("应该抛出区域超出边界错误")
        } catch ScreenshotError.regionOutOfBounds {
            // 预期的错误
        } catch {
            XCTFail("意外的错误类型: \(error)")
        }
    }
    
    // 测试性能
    func testScreenshotPerformance() {
        let config = ScreenshotConfig(
            captureType: .fullscreen,
            targetDisplay: NSScreen.main,
            region: nil,
            includeWindowShadow: false,
            outputFormat: .png(.medium),
            quality: 1.0,
            includeMouseCursor: false,
            delaySeconds: 0
        )
        
        measure {
            Task {
                do {
                    _ = try await screenshotEngine.captureScreen(config: config)
                } catch {
                    XCTFail("截图失败: \(error)")
                }
            }
        }
    }
}
```

### 2.2 录制模块测试
```swift
class RecordingEngineTests: XCTestCase {
    var recordingEngine: RecordingEngine!
    
    override func setUp() {
        super.setUp()
        recordingEngine = RecordingEngine()
    }
    
    override func tearDown() {
        recordingEngine = nil
        super.tearDown()
    }
    
    // 测试录制配置验证
    func testRecordingConfigValidation() {
        let validConfig = RecordingConfig(
            captureType: .fullscreen,
            region: nil,
            frameRate: 30,
            resolution: CGSize(width: 1920, height: 1080),
            videoCodec: .h264(.main),
            audioConfig: nil,
            outputFormat: .mp4(.h264),
            quality: .high,
            maxDuration: 3600,
            includeMouseCursor: true
        )
        
        let validationResult = recordingEngine.validateConfig(validConfig)
        XCTAssertTrue(validationResult.isValid)
        XCTAssertTrue(validationResult.errors.isEmpty)
    }
    
    // 测试无效配置处理
    func testInvalidConfigHandling() {
        let invalidConfig = RecordingConfig(
            captureType: .region,
            region: nil, // 区域录制但未指定区域
            frameRate: 120, // 不支持的帧率
            resolution: CGSize(width: 0, height: 0), // 无效分辨率
            videoCodec: .h264(.main),
            audioConfig: nil,
            outputFormat: .mp4(.h264),
            quality: .high,
            maxDuration: -1, // 无效时长
            includeMouseCursor: true
        )
        
        let validationResult = recordingEngine.validateConfig(invalidConfig)
        XCTAssertFalse(validationResult.isValid)
        XCTAssertGreaterThan(validationResult.errors.count, 0)
    }
    
    // 测试录制状态管理
    func testRecordingStateManagement() async throws {
        let config = RecordingConfig(
            captureType: .fullscreen,
            region: nil,
            frameRate: 30,
            resolution: CGSize(width: 1280, height: 720),
            videoCodec: .h264(.main),
            audioConfig: nil,
            outputFormat: .mp4(.h264),
            quality: .medium,
            maxDuration: 10,
            includeMouseCursor: false
        )
        
        // 初始状态
        XCTAssertFalse(recordingEngine.isRecording)
        XCTAssertFalse(recordingEngine.isPaused)
        
        // 开始录制
        try await recordingEngine.startRecording(config: config)
        XCTAssertTrue(recordingEngine.isRecording)
        XCTAssertFalse(recordingEngine.isPaused)
        
        // 暂停录制
        try await recordingEngine.pauseRecording()
        XCTAssertTrue(recordingEngine.isRecording)
        XCTAssertTrue(recordingEngine.isPaused)
        
        // 恢复录制
        try await recordingEngine.resumeRecording()
        XCTAssertTrue(recordingEngine.isRecording)
        XCTAssertFalse(recordingEngine.isPaused)
        
        // 停止录制
        let result = try await recordingEngine.stopRecording()
        XCTAssertFalse(recordingEngine.isRecording)
        XCTAssertFalse(recordingEngine.isPaused)
        XCTAssertNotNil(result.videoURL)
        XCTAssertGreaterThan(result.duration, 0)
    }
}
```

### 2.3 编辑模块测试
```swift
class EditingEngineTests: XCTestCase {
    var editingEngine: EditingEngine!
    var testImage: NSImage!
    
    override func setUp() {
        super.setUp()
        editingEngine = EditingEngine()
        testImage = createTestImage()
    }
    
    override func tearDown() {
        editingEngine = nil
        testImage = nil
        super.tearDown()
    }
    
    // 测试图像加载
    func testImageLoading() async throws {
        let imageContent = ImageContent(image: testImage)
        
        try await editingEngine.loadContent(imageContent)
        
        XCTAssertNotNil(editingEngine.currentContent)
        XCTAssertEqual(editingEngine.currentContent?.contentType, .image)
    }
    
    // 测试标注添加
    func testAnnotationAddition() async throws {
        let imageContent = ImageContent(image: testImage)
        try await editingEngine.loadContent(imageContent)
        
        let annotation = Annotation(
            type: .arrow(.default),
            bounds: CGRect(x: 10, y: 10, width: 50, height: 20),
            properties: [:]
        )
        
        let operation = EditOperation(
            type: .addAnnotation(.arrow(.default)),
            parameters: ["annotation": annotation],
            targetRect: annotation.bounds,
            duration: nil
        )
        
        let result = try await editingEngine.applyOperation(operation)
        
        XCTAssertNotNil(result.editedContent)
        XCTAssertEqual(editingEngine.operationHistory.count, 1)
        XCTAssertTrue(editingEngine.canUndo)
        XCTAssertFalse(editingEngine.canRedo)
    }
    
    // 测试撤销重做功能
    func testUndoRedo() async throws {
        let imageContent = ImageContent(image: testImage)
        try await editingEngine.loadContent(imageContent)
        
        // 添加第一个操作
        let operation1 = EditOperation(
            type: .addAnnotation(.text(.default)),
            parameters: [:],
            targetRect: CGRect(x: 0, y: 0, width: 100, height: 20),
            duration: nil
        )
        
        _ = try await editingEngine.applyOperation(operation1)
        XCTAssertEqual(editingEngine.operationHistory.count, 1)
        XCTAssertTrue(editingEngine.canUndo)
        
        // 添加第二个操作
        let operation2 = EditOperation(
            type: .addAnnotation(.rectangle(.default)),
            parameters: [:],
            targetRect: CGRect(x: 50, y: 50, width: 100, height: 100),
            duration: nil
        )
        
        _ = try await editingEngine.applyOperation(operation2)
        XCTAssertEqual(editingEngine.operationHistory.count, 2)
        
        // 撤销操作
        let undoResult = try await editingEngine.undo()
        XCTAssertTrue(undoResult)
        XCTAssertEqual(editingEngine.operationHistory.count, 1)
        XCTAssertTrue(editingEngine.canRedo)
        
        // 重做操作
        let redoResult = try await editingEngine.redo()
        XCTAssertTrue(redoResult)
        XCTAssertEqual(editingEngine.operationHistory.count, 2)
        XCTAssertFalse(editingEngine.canRedo)
    }
    
    private func createTestImage() -> NSImage {
        let size = CGSize(width: 200, height: 200)
        let image = NSImage(size: size)
        
        image.lockFocus()
        NSColor.white.setFill()
        NSRect(origin: .zero, size: size).fill()
        image.unlockFocus()
        
        return image
    }
}
```

### 2.4 文件管理模块测试
```swift
class FileManagerTests: XCTestCase {
    var fileManager: FileManager!
    var tempDirectory: URL!
    
    override func setUp() {
        super.setUp()
        fileManager = FileManager()
        tempDirectory = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try? FileManager.default.createDirectory(at: tempDirectory, withIntermediateDirectories: true)
    }
    
    override func tearDown() {
        try? FileManager.default.removeItem(at: tempDirectory)
        fileManager = nil
        tempDirectory = nil
        super.tearDown()
    }
    
    // 测试图像保存
    func testImageSaving() async throws {
        let testImage = createTestImage()
        let config = FileSaveConfig(
            outputPath: tempDirectory.appendingPathComponent("test.png"),
            format: .png(.medium),
            quality: 1.0,
            compressionLevel: 5,
            metadata: [:],
            namingRule: NamingRule(
                prefix: "test",
                includeTimestamp: false,
                timestampFormat: "",
                includeSequenceNumber: false,
                customSuffix: ""
            ),
            overwriteExisting: true
        )
        
        let savedURL = try await fileManager.saveImage(testImage, config: config)
        
        XCTAssertTrue(FileManager.default.fileExists(atPath: savedURL.path))
        XCTAssertEqual(savedURL.pathExtension, "png")
    }
    
    // 测试批量处理
    func testBatchProcessing() async throws {
        // 创建测试文件
        let testFiles = try createTestFiles(count: 3)
        
        let config = BatchProcessConfig(
            sourceFiles: testFiles,
            operations: [.convertFormat(to: .jpeg(0.8))],
            outputDirectory: tempDirectory.appendingPathComponent("batch_output"),
            namingPattern: "converted_%original%",
            preserveStructure: false,
            skipErrors: true
        )
        
        let results = try await fileManager.processBatch(config: config)
        
        XCTAssertEqual(results.count, 3)
        XCTAssertTrue(results.allSatisfy { $0.success })
    }
    
    // 测试文件验证
    func testFileValidation() async throws {
        let testImage = createTestImage()
        let testURL = tempDirectory.appendingPathComponent("validation_test.png")
        
        let config = FileSaveConfig(
            outputPath: testURL,
            format: .png(.medium),
            quality: 1.0,
            compressionLevel: 5,
            metadata: [:],
            namingRule: NamingRule(prefix: "", includeTimestamp: false, timestampFormat: "", includeSequenceNumber: false, customSuffix: ""),
            overwriteExisting: true
        )
        
        _ = try await fileManager.saveImage(testImage, config: config)
        
        let isValid = try await fileManager.validateFileIntegrity(testURL)
        XCTAssertTrue(isValid)
    }
    
    private func createTestImage() -> NSImage {
        let size = CGSize(width: 100, height: 100)
        let image = NSImage(size: size)
        
        image.lockFocus()
        NSColor.blue.setFill()
        NSRect(origin: .zero, size: size).fill()
        image.unlockFocus()
        
        return image
    }
    
    private func createTestFiles(count: Int) throws -> [URL] {
        var files: [URL] = []
        
        for i in 0..<count {
            let fileURL = tempDirectory.appendingPathComponent("test_\(i).png")
            let testImage = createTestImage()
            
            let config = FileSaveConfig(
                outputPath: fileURL,
                format: .png(.medium),
                quality: 1.0,
                compressionLevel: 5,
                metadata: [:],
                namingRule: NamingRule(prefix: "", includeTimestamp: false, timestampFormat: "", includeSequenceNumber: false, customSuffix: ""),
                overwriteExisting: true
            )
            
            _ = try await fileManager.saveImage(testImage, config: config)
            files.append(fileURL)
        }
        
        return files
    }
}
```

## 3. 集成测试

### 3.1 模块间交互测试
```swift
class IntegrationTests: XCTestCase {
    var screenshotEngine: ScreenshotEngine!
    var editingEngine: EditingEngine!
    var fileManager: FileManager!
    
    override func setUp() {
        super.setUp()
        screenshotEngine = ScreenshotEngine()
        editingEngine = EditingEngine()
        fileManager = FileManager()
    }
    
    // 测试截图到编辑的完整流程
    func testScreenshotToEditingWorkflow() async throws {
        // 1. 截图
        let screenshotConfig = ScreenshotConfig(
            captureType: .fullscreen,
            targetDisplay: NSScreen.main,
            region: nil,
            includeWindowShadow: false,
            outputFormat: .png(.medium),
            quality: 1.0,
            includeMouseCursor: false,
            delaySeconds: 0
        )
        
        let screenshotResult = try await screenshotEngine.captureScreen(config: screenshotConfig)
        XCTAssertNotNil(screenshotResult.image)
        
        // 2. 加载到编辑器
        let imageContent = ImageContent(image: screenshotResult.image)
        try await editingEngine.loadContent(imageContent)
        XCTAssertNotNil(editingEngine.currentContent)
        
        // 3. 添加标注
        let annotation = Annotation(
            type: .text(.default),
            bounds: CGRect(x: 100, y: 100, width: 200, height: 50),
            properties: ["text": "测试标注"]
        )
        
        let editOperation = EditOperation(
            type: .addAnnotation(.text(.default)),
            parameters: ["annotation": annotation],
            targetRect: annotation.bounds,
            duration: nil
        )
        
        let editResult = try await editingEngine.applyOperation(editOperation)
        XCTAssertNotNil(editResult.editedContent)
        
        // 4. 保存编辑结果
        let saveConfig = FileSaveConfig(
            outputPath: FileManager.default.temporaryDirectory.appendingPathComponent("edited_screenshot.png"),
            format: .png(.medium),
            quality: 1.0,
            compressionLevel: 5,
            metadata: [:],
            namingRule: NamingRule(prefix: "", includeTimestamp: false, timestampFormat: "", includeSequenceNumber: false, customSuffix: ""),
            overwriteExisting: true
        )
        
        if let editedImage = editResult.editedContent as? NSImage {
            let savedURL = try await fileManager.saveImage(editedImage, config: saveConfig)
            XCTAssertTrue(FileManager.default.fileExists(atPath: savedURL.path))
        }
    }
    
    // 测试录制到编辑的完整流程
    func testRecordingToEditingWorkflow() async throws {
        let recordingEngine = RecordingEngine()
        
        // 1. 开始录制
        let recordingConfig = RecordingConfig(
            captureType: .fullscreen,
            region: nil,
            frameRate: 30,
            resolution: CGSize(width: 1280, height: 720),
            videoCodec: .h264(.main),
            audioConfig: nil,
            outputFormat: .mp4(.h264),
            quality: .medium,
            maxDuration: 5, // 5秒测试录制
            includeMouseCursor: false
        )
        
        try await recordingEngine.startRecording(config: recordingConfig)
        XCTAssertTrue(recordingEngine.isRecording)
        
        // 等待一段时间
        try await Task.sleep(nanoseconds: 2_000_000_000) // 2秒
        
        // 2. 停止录制
        let recordingResult = try await recordingEngine.stopRecording()
        XCTAssertNotNil(recordingResult.videoURL)
        XCTAssertGreaterThan(recordingResult.duration, 1.0)
        
        // 3. 加载视频到编辑器
        let videoAsset = AVAsset(url: recordingResult.videoURL)
        let videoContent = VideoContent(asset: videoAsset)
        try await editingEngine.loadContent(videoContent)
        XCTAssertNotNil(editingEngine.currentContent)
        XCTAssertEqual(editingEngine.currentContent?.contentType, .video)
        
        // 4. 添加水印
        let watermarkInfo = WatermarkInfo(
            image: createTestWatermark(),
            position: .bottomRight,
            opacity: 0.7,
            scale: 0.2
        )
        
        let watermarkOperation = EditOperation(
            type: .addWatermark(watermarkInfo),
            parameters: ["watermark": watermarkInfo],
            targetRect: nil,
            duration: nil
        )
        
        let editResult = try await editingEngine.applyOperation(watermarkOperation)
        XCTAssertNotNil(editResult.editedContent)
    }
    
    private func createTestWatermark() -> NSImage {
        let size = CGSize(width: 100, height: 50)
        let image = NSImage(size: size)
        
        image.lockFocus()
        NSColor.red.withAlphaComponent(0.7).setFill()
        NSRect(origin: .zero, size: size).fill()
        
        let text = "WATERMARK"
        let attributes: [NSAttributedString.Key: Any] = [
            .font: NSFont.boldSystemFont(ofSize: 12),
            .foregroundColor: NSColor.white
        ]
        
        let attributedString = NSAttributedString(string: text, attributes: attributes)
        let textSize = attributedString.size()
        let textRect = CGRect(
            x: (size.width - textSize.width) / 2,
            y: (size.height - textSize.height) / 2,
            width: textSize.width,
            height: textSize.height
        )
        
        attributedString.draw(in: textRect)
        image.unlockFocus()
        
        return image
    }
}
```

## 4. 性能测试

### 4.1 性能基准测试
```swift
class PerformanceTests: XCTestCase {
    
    // 测试截图性能
    func testScreenshotPerformance() {
        let screenshotEngine = ScreenshotEngine()
        let config = ScreenshotConfig(
            captureType: .fullscreen,
            targetDisplay: NSScreen.main,
            region: nil,
            includeWindowShadow: false,
            outputFormat: .png(.medium),
            quality: 1.0,
            includeMouseCursor: false,
            delaySeconds: 0
        )
        
        measure {
            Task {
                do {
                    _ = try await screenshotEngine.captureScreen(config: config)
                } catch {
                    XCTFail("截图性能测试失败: \(error)")
                }
            }
        }
    }
    
    // 测试大图像编辑性能
    func testLargeImageEditingPerformance() {
        let editingEngine = EditingEngine()
        let largeImage = createLargeTestImage()
        
        measure {
            Task {
                do {
                    let imageContent = ImageContent(image: largeImage)
                    try await editingEngine.loadContent(imageContent)
                    
                    let operation = EditOperation(
                        type: .addAnnotation(.rectangle(.default)),
                        parameters: [:],
                        targetRect: CGRect(x: 100, y: 100, width: 200, height: 200),
                        duration: nil
                    )
                    
                    _ = try await editingEngine.applyOperation(operation)
                } catch {
                    XCTFail("大图像编辑性能测试失败: \(error)")
                }
            }
        }
    }
    
    // 测试批量文件处理性能
    func testBatchProcessingPerformance() {
        let fileManager = FileManager()
        let testFiles = createMultipleTestFiles(count: 10)
        
        let config = BatchProcessConfig(
            sourceFiles: testFiles,
            operations: [.convertFormat(to: .jpeg(0.8))],
            outputDirectory: FileManager.default.temporaryDirectory.appendingPathComponent("batch_perf_test"),
            namingPattern: "converted_%original%",
            preserveStructure: false,
            skipErrors: true
        )
        
        measure {
            Task {
                do {
                    _ = try await fileManager.processBatch(config: config)
                } catch {
                    XCTFail("批量处理性能测试失败: \(error)")
                }
            }
        }
    }
    
    // 测试内存使用
    func testMemoryUsage() {
        let screenshotEngine = ScreenshotEngine()
        let initialMemory = getMemoryUsage()
        
        // 执行多次截图操作
        for _ in 0..<10 {
            Task {
                let config = ScreenshotConfig(
                    captureType: .fullscreen,
                    targetDisplay: NSScreen.main,
                    region: nil,
                    includeWindowShadow: false,
                    outputFormat: .png(.medium),
                    quality: 1.0,
                    includeMouseCursor: false,
                    delaySeconds: 0
                )
                
                do {
                    _ = try await screenshotEngine.captureScreen(config: config)
                } catch {
                    XCTFail("内存测试中截图失败: \(error)")
                }
            }
        }
        
        let finalMemory = getMemoryUsage()
        let memoryIncrease = finalMemory - initialMemory
        
        // 内存增长应该在合理范围内 (< 100MB)
        XCTAssertLessThan(memoryIncrease, 100 * 1024 * 1024, "内存使用增长过多")
    }
    
    private func createLargeTestImage() -> NSImage {
        let size = CGSize(width: 4000, height: 3000) // 4K图像
        let image = NSImage(size: size)
        
        image.lockFocus()
        NSColor.blue.setFill()
        NSRect(origin: .zero, size: size).fill()
        image.unlockFocus()
        
        return image
    }
    
    private func createMultipleTestFiles(count: Int) -> [URL] {
        var files: [URL] = []
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent("perf_test_files")
        
        try? FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        for i in 0..<count {
            let fileURL = tempDir.appendingPathComponent("test_\(i).png")
            let testImage = NSImage(size: CGSize(width: 500, height: 500))
            
            testImage?.lockFocus()
            NSColor.random.setFill()
            NSRect(origin: .zero, size: CGSize(width: 500, height: 500)).fill()
            testImage?.unlockFocus()
            
            // 保存图像到文件
            if let tiffData = testImage?.tiffRepresentation,
               let bitmapRep = NSBitmapImageRep(data: tiffData),
               let pngData = bitmapRep.representation(using: .png, properties: [:]) {
                try? pngData.write(to: fileURL)
                files.append(fileURL)
            }
        }
        
        return files
    }
    
    private func getMemoryUsage() -> Int64 {
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_,
                         task_flavor_t(MACH_TASK_BASIC_INFO),
                         $0,
                         &count)
            }
        }
        
        if kerr == KERN_SUCCESS {
            return Int64(info.resident_size)
        } else {
            return 0
        }
    }
}

extension NSColor {
    static var random: NSColor {
        return NSColor(
            red: CGFloat.random(in: 0...1),
            green: CGFloat.random(in: 0...1),
            blue: CGFloat.random(in: 0...1),
            alpha: 1.0
        )
    }
}
```

## 5. 兼容性测试

### 5.1 系统版本兼容性测试
```swift
class CompatibilityTests: XCTestCase {
    
    // 测试macOS版本兼容性
    func testMacOSVersionCompatibility() {
        let systemVersion = ProcessInfo.processInfo.operatingSystemVersion
        
        // 检查最低支持版本 (macOS 10.15)
        XCTAssertGreaterThanOrEqual(systemVersion.majorVersion, 10)
        if systemVersion.majorVersion == 10 {
            XCTAssertGreaterThanOrEqual(systemVersion.minorVersion, 15)
        }
        
        // 测试版本特定功能
        if #available(macOS 11.0, *) {
            // 测试Big Sur及以上版本的功能
            testBigSurSpecificFeatures()
        }
        
        if #available(macOS 12.0, *) {
            // 测试Monterey及以上版本的功能
            testMontereySpecificFeatures()
        }
    }
    
    // 测试硬件兼容性
    func testHardwareCompatibility() {
        let systemInfo = getSystemInfo()
        
        // 检查处理器类型
        if systemInfo.isAppleSilicon {
            testAppleSiliconFeatures()
        } else {
            testIntelFeatures()
        }
        
        // 检查内存
        XCTAssertGreaterThanOrEqual(systemInfo.totalMemory, 4 * 1024 * 1024 * 1024) // 最少4GB
        
        // 检查显卡支持
        XCTAssertTrue(systemInfo.supportsMetalAPI, "系统必须支持Metal API")
    }
    
    // 测试多显示器环境
    func testMultiDisplaySupport() {
        let screens = NSScreen.screens
        
        if screens.count > 1 {
            // 测试多显示器截图
            for screen in screens {
                let config = ScreenshotConfig(
                    captureType: .fullscreen,
                    targetDisplay: screen,
                    region: nil,
                    includeWindowShadow: false,
                    outputFormat: .png(.medium),
                    quality: 1.0,
                    includeMouseCursor: false,
                    delaySeconds: 0
                )
                
                Task {
                    do {
                        let screenshotEngine = ScreenshotEngine()
                        let result = try await screenshotEngine.captureScreen(config: config)
                        XCTAssertNotNil(result.image)
                        XCTAssertEqual(result.image.size.width, screen.frame.width)
                        XCTAssertEqual(result.image.size.height, screen.frame.height)
                    } catch {
                        XCTFail("多显示器截图失败: \(error)")
                    }
                }
            }
        }
    }
    
    @available(macOS 11.0, *)
    private func testBigSurSpecificFeatures() {
        // 测试Big Sur特有功能
        // 例如：新的权限API、UI改进等
    }
    
    @available(macOS 12.0, *)
    private func testMontereySpecificFeatures() {
        // 测试Monterey特有功能
        // 例如：AirPlay接收器、快捷指令等
    }
    
    private func testAppleSiliconFeatures() {
        // 测试Apple Silicon特有功能
        // 例如：硬件加速、性能优化等
    }
    
    private func testIntelFeatures() {
        // 测试Intel处理器特有功能
    }
    
    private func getSystemInfo() -> SystemInfo {
        // 获取系统信息的实现
        return SystemInfo(
            isAppleSilicon: isAppleSilicon(),
            totalMemory: getTotalMemory(),
            supportsMetalAPI: supportsMetalAPI()
        )
    }
    
    private func isAppleSilicon() -> Bool {
        var size = 0
        sysctlbyname("hw.optional.arm64", nil, &size, nil, 0)
        return size > 0
    }
    
    private func getTotalMemory() -> Int64 {
        var size: size_t = MemoryLayout<Int64>.size
        var result: Int64 = 0
        sysctlbyname("hw.memsize", &result, &size, nil, 0)
        return result
    }
    
    private func supportsMetalAPI() -> Bool {
        return MTLCreateSystemDefaultDevice() != nil
    }
}

struct SystemInfo {
    let isAppleSilicon: Bool
    let totalMemory: Int64
    let supportsMetalAPI: Bool
}
```

## 6. 测试执行和报告

### 6.1 持续集成配置
```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: macos-latest
    
    strategy:
      matrix:
        xcode: ['15.0', '14.3']
        
    steps:
    - uses: actions/checkout@v3
    
    - name: Select Xcode
      run: sudo xcode-select -switch /Applications/Xcode_${{ matrix.xcode }}.app/Contents/Developer
      
    - name: Build and Test
      run: |
        xcodebuild test \
          -scheme ScreenCapture \
          -destination 'platform=macOS' \
          -enableCodeCoverage YES \
          -resultBundlePath TestResults
          
    - name: Generate Coverage Report
      run: |
        xcrun xccov view --report --json TestResults.xcresult > coverage.json
        
    - name: Upload Coverage
      uses: codecov/codecov-action@v3
      with:
        file: coverage.json
```

### 6.2 测试报告生成
```swift
// TestReportGenerator.swift
class TestReportGenerator {
    static func generateReport(from results: XCTestSuiteRun) -> TestReport {
        let report = TestReport()
        
        report.totalTests = results.testCaseCount
        report.passedTests = results.testCaseCount - Int(results.failureCount)
        report.failedTests = Int(results.failureCount)
        report.executionTime = results.testDuration
        report.codeCoverage = getCodeCoverage()
        
        return report
    }
    
    private static func getCodeCoverage() -> Double {
        // 从Xcode测试结果中提取代码覆盖率
        return 0.85 // 示例值
    }
}

struct TestReport {
    var totalTests: Int = 0
    var passedTests: Int = 0
    var failedTests: Int = 0
    var executionTime: TimeInterval = 0
    var codeCoverage: Double = 0
    
    var successRate: Double {
        guard totalTests > 0 else { return 0 }
        return Double(passedTests) / Double(totalTests)
    }
}
```

## 7. 测试数据管理

### 7.1 测试数据准备
```swift
class TestDataManager {
    static let shared = TestDataManager()
    
    private let testDataDirectory: URL
    
    init() {
        testDataDirectory = FileManager.default.temporaryDirectory
            .appendingPathComponent("ScreenCaptureTestData")
        
        setupTestData()
    }
    
    func getTestImage(size: CGSize = CGSize(width: 100, height: 100)) -> NSImage {
        let image = NSImage(size: size)
        image.lockFocus()
        NSColor.blue.setFill()
        NSRect(origin: .zero, size: size).fill()
        image.unlockFocus()
        return image
    }
    
    func getTestVideo(duration: TimeInterval = 5.0) -> URL {
        // 生成测试视频文件
        let videoURL = testDataDirectory.appendingPathComponent("test_video.mp4")
        
        // 如果文件不存在，创建一个简单的测试视频
        if !FileManager.default.fileExists(atPath: videoURL.path) {
            createTestVideo(at: videoURL, duration: duration)
        }
        
        return videoURL
    }
    
    func cleanupTestData() {
        try? FileManager.default.removeItem(at: testDataDirectory)
    }
    
    private func setupTestData() {
        try? FileManager.default.createDirectory(
            at: testDataDirectory,
            withIntermediateDirectories: true
        )
    }
    
    private func createTestVideo(at url: URL, duration: TimeInterval) {
        // 创建简单的测试视频
        // 实际实现会使用AVFoundation创建视频
    }
}
```

---

**文档版本**: 1.0.0  
**创建日期**: 2025年9月25日  
**最后更新**: 2025年9月25日